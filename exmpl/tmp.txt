/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_commands_with_pipe.c                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nmatondo <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 10:05:31 by nmatondo          #+#    #+#             */
/*   Updated: 2024/11/06 10:05:31 by nmatondo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	change_fd(t_new_list *aux, t_data *data)
{
	if (aux != data->list)
	{
		dup2(data->cpy_read_pipe_operation, STDIN_FILENO);
		close(data->cpy_read_pipe_operation);
	}
	if (aux->next != NULL)
	{
		dup2(data->write_pipe_operation, STDOUT_FILENO);
		close(data->write_pipe_operation);
		close(data->read_pipe_operation);
	}
	// if (aux->next == NULL)
	// {
	// 	dup2(data->cpy_write_operation, STDOUT_FILENO);
	// 	close(data->cpy_write_operation);
	// }
}

static void	pass_the_fd(t_new_list *aux, t_data *data)
{
	if (data->cpy_read_pipe_operation != -1)
		close(data->cpy_read_pipe_operation);
	if (aux->next != NULL)
	{
		close(data->write_pipe_operation);
		data->cpy_read_pipe_operation = data->read_pipe_operation;
	}
}

static void	execute_commands(int value_redirection, t_new_list *aux,
	t_data *data)
{
	if (value_redirection == 1)
	{
		dprintf(2, "value_redirection (%s)", aux->content[0]);
		redirection(aux, data);
	}
	else if (value_redirection == 0)
	{
		dprintf(2, "(%s)\n", aux->content[0]);
		execute_command(0, aux, data);
	}
}

static void	close_fds(t_data *data)
{
	if (data->write_pipe_operation != -1)
		close(data->write_pipe_operation);
	if (data->read_pipe_operation != -1)
		close(data->read_pipe_operation);
	if (data->cpy_read_pipe_operation != -1)
		close(data->cpy_read_pipe_operation);
}

void	execute_commands_with_pipe(int value_redirection, t_data *data)
{
	pid_t		pid;
	int			pipefd[2];
	// char		buffer[9000];
	t_new_list	*aux;

	data->cpy_read_operation = dup(STDIN_FILENO);
	data->cpy_write_operation = dup(STDOUT_FILENO);
	aux = data->list;

	// ft_show_lstnew(aux);
	// ft_printf("\n\n\n");

	while (aux)
	{
		if (aux->next != NULL)
		{
			pipe(pipefd);
			data->write_pipe_operation = pipefd[1];
			data->read_pipe_operation = pipefd[0];
		}
		pid = fork();
		if (pid == 0)
		{
			change_fd(aux, data);
			

			// if (aux->next == NULL)
			// {
			// 	read(STDIN_FILENO, buffer, 9000);
			// 	ft_printf("[%s]\n", buffer);
			// 	if (isatty(STDIN_FILENO)) {printf("Entrada padrão é um terminal.\n");} else {printf("Entrada padrão não é um terminal.\n");}
			// 	if (isatty(STDOUT_FILENO)) {printf("Saída padrão é um terminal.\n");} else {printf("Saída padrão não é um terminal.\n");}
			// }
			// else
			execute_commands(value_redirection, aux, data);

			exit(0);
		}
		else
		{
			pass_the_fd(aux, data);
			wait(NULL);
		}
		aux = aux->next;
	}
	close_fds(data);
}



int	double_left_redirect(int i, t_data *data, t_red_fd *red_fd)
{
	int	fd;
	int	len_m;

	len_m = len_matrix(data->redirection_matrix);
	if ((i + 2) < len_m)
	{
		heredoc(data, data->redirection_matrix[i + 1]);
		if (red_fd->first_fd != -1)
			close(red_fd->first_fd);
		red_fd->first_fd = dup(data->read_in_the_pipe);
		close(data->read_in_the_pipe);
		close(data->write_on_the_pipe);
		fd = dup(STDOUT_FILENO);
	}
	else
	{
		heredoc(data, data->redirection_matrix[i + 1]);
		fd = dup(data->read_in_the_pipe);
		close(data->read_in_the_pipe);
		close(data->write_on_the_pipe);
	}
	return (fd);
}



ls -l | grep c > file1.txt
cat Makefile | grep .c >> file2.txt
sort < Makefile | uniq > file3.txt





char	**allocation_of_environment_variable_with_space(char **cpy_matrix, char **matrix, t_data *data)
{
	int		i;
	char	**new_matrix;

	i = 0;
	(void)data;
	(void)matrix;
	(void)new_matrix;
	while (cpy_matrix[i])
	{
		ft_printf("%i - {%s}", i, matrix[i]);
		ft_printf("[%s]\n", cpy_matrix[i]);
		i++;
	}
	//  free() new_matrix matrix
	return (NULL);
}

char	**dup_matrix(char **matrix)
{
	int		i;
	int		len;
	char	**new_matrix;

	len = len_matrix(matrix);
	new_matrix = (char **)ft_calloc((len + 1), sizeof(char *));
	if (!new_matrix)
		return (NULL);
	i = 0;
	while (i < len)
	{
		new_matrix[i] = strdup(matrix[i]);
		if (!new_matrix[i])
		{
			while (i > 0)
				free(new_matrix[--i]);
			free(new_matrix);
			return (NULL);
		}
		i++;
	}
	new_matrix[len] = NULL;
	return (new_matrix);
}

void	insert_data(t_data *data, char *command)
{
	int		i;
	int		len_m;
	char	**matrix;
	char	**spliting;
	char	**new_matrix;

	i = 0;
	data->command = command;
	spliting = split_2(command, '|');
	len_m = len_matrix(spliting);
	if (len_m > 1)
		data->is_pipe = true;
	else
		data->is_pipe = false;
	while (spliting[i])
	{
		matrix = split_2(spliting[i], ' ');
		matrix_space_position_adjustment(&matrix);
		null_string(&matrix);
		//////////////////////////////////////////////////////////////////////////////////
		new_matrix = dup_matrix(matrix);
		environment_variation_expansion(&matrix, data);
		//////////////////////////////////////////////////////////////////////////////////
		matrix_space_position_adjustment(&new_matrix);
		matrix_space_position_adjustment(&matrix);
		//////////////////////////////////////////////////////////////////////////////////
		// matrix = 
		allocation_of_environment_variable_with_space(new_matrix, matrix, data);
		//////////////////////////////////////////////////////////////////////////////////
		ft_lstnew_addback(&data->list, ft_lstnew_new(matrix));
		free(spliting[i]);
		i++;
	}
	free(spliting);
}




