/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_commands_with_pipe.c                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nmatondo <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 10:05:31 by nmatondo          #+#    #+#             */
/*   Updated: 2024/11/06 10:05:31 by nmatondo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	change_fd(t_new_list *aux, t_data *data)
{
	if (aux != data->list)
	{
		dup2(data->cpy_read_pipe_operation, STDIN_FILENO);
		close(data->cpy_read_pipe_operation);
	}
	if (aux->next != NULL)
	{
		dup2(data->write_pipe_operation, STDOUT_FILENO);
		close(data->write_pipe_operation);
		close(data->read_pipe_operation);
	}
	// if (aux->next == NULL)
	// {
	// 	dup2(data->cpy_write_operation, STDOUT_FILENO);
	// 	close(data->cpy_write_operation);
	// }
}

static void	pass_the_fd(t_new_list *aux, t_data *data)
{
	if (data->cpy_read_pipe_operation != -1)
		close(data->cpy_read_pipe_operation);
	if (aux->next != NULL)
	{
		close(data->write_pipe_operation);
		data->cpy_read_pipe_operation = data->read_pipe_operation;
	}
}

static void	execute_commands(int value_redirection, t_new_list *aux,
	t_data *data)
{
	if (value_redirection == 1)
	{
		dprintf(2, "value_redirection (%s)", aux->content[0]);
		redirection(aux, data);
	}
	else if (value_redirection == 0)
	{
		dprintf(2, "(%s)\n", aux->content[0]);
		execute_command(0, aux, data);
	}
}

static void	close_fds(t_data *data)
{
	if (data->write_pipe_operation != -1)
		close(data->write_pipe_operation);
	if (data->read_pipe_operation != -1)
		close(data->read_pipe_operation);
	if (data->cpy_read_pipe_operation != -1)
		close(data->cpy_read_pipe_operation);
}

void	execute_commands_with_pipe(int value_redirection, t_data *data)
{
	pid_t		pid;
	int			pipefd[2];
	// char		buffer[9000];
	t_new_list	*aux;

	data->cpy_read_operation = dup(STDIN_FILENO);
	data->cpy_write_operation = dup(STDOUT_FILENO);
	aux = data->list;

	// ft_show_lstnew(aux);
	// ft_printf("\n\n\n");

	while (aux)
	{
		if (aux->next != NULL)
		{
			pipe(pipefd);
			data->write_pipe_operation = pipefd[1];
			data->read_pipe_operation = pipefd[0];
		}
		pid = fork();
		if (pid == 0)
		{
			change_fd(aux, data);
			

			// if (aux->next == NULL)
			// {
			// 	read(STDIN_FILENO, buffer, 9000);
			// 	ft_printf("[%s]\n", buffer);
			// 	if (isatty(STDIN_FILENO)) {printf("Entrada padrão é um terminal.\n");} else {printf("Entrada padrão não é um terminal.\n");}
			// 	if (isatty(STDOUT_FILENO)) {printf("Saída padrão é um terminal.\n");} else {printf("Saída padrão não é um terminal.\n");}
			// }
			// else
			execute_commands(value_redirection, aux, data);

			exit(0);
		}
		else
		{
			pass_the_fd(aux, data);
			wait(NULL);
		}
		aux = aux->next;
	}
	close_fds(data);
}


bool	condition(char *str)
{
	return (ft_strncmp(str, ">", 1) == 0 && ft_strlen(str) == 1)
			|| (ft_strncmp(str, ">>", 2) == 0 && ft_strlen(str) == 2)
			|| (ft_strncmp(str, "<>", 2) == 0 && ft_strlen(str) == 2);
}


ls -l | grep c > file1.txt
cat Makefile | grep .c >> file2.txt
sort < Makefile | uniq > file3.txt


static void	free_redirection_matrix(t_data *data)
{
	if (data->redirection_matrix != NULL)
	{
		free_matrix(data->redirection_matrix);
		data->redirection_matrix = NULL;
	}
}